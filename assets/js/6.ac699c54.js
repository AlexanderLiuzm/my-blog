(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{217:function(e,a,t){e.exports=t.p+"assets/img/batch_merge_cells_target.9c3edd8b.jpg"},218:function(e,a,t){e.exports=t.p+"assets/img/batch_merge_cells_locate.889cdb49.gif"},219:function(e,a,t){e.exports=t.p+"assets/img/batch_merge_cells_record_macro.90947f25.png"},244:function(e,a,t){"use strict";t.r(a);var s=t(0),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"为什么要处理合并单元格"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要处理合并单元格"}},[e._v("#")]),e._v(" 为什么要处理合并单元格")]),e._v(" "),s("p",[e._v("因为在数据处理当中一维的表格处理起来最为方便，可以汇总为二维的表格或者其他自己想要的表格。但矛盾就在这里，"),s("em",[e._v("合并单元格")]),e._v("大大降低了表格的可处理性，无论是筛选，排序还是统计（"),s("code",[e._v("sumif")]),e._v("），都会产生错误，对后续的处理操作带来极大的麻烦。因此在数据处理操作之前要对合并单元格进行处理。")]),e._v(" "),s("h1",{attrs:{id:"目标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目标"}},[e._v("#")]),e._v(" 目标")]),e._v(" "),s("p",[e._v("让合并的单元格都取消合并，并且都填充对应的值。")]),e._v(" "),s("p",[s("img",{attrs:{src:t(217),alt:"enter image description here"}})]),e._v(" "),s("h1",{attrs:{id:"思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[e._v("#")]),e._v(" 思路")]),e._v(" "),s("h2",{attrs:{id:"循环法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环法"}},[e._v("#")]),e._v(" 循环法")]),e._v(" "),s("p",[e._v("先把合并单元格进行恢复，取消合并。再对一列单元格进行逐一的检验。如果单元格内含有数据，那就不做处理；如果单元格内没有数据，那就把这个单元格的上一列的数据赋值给它。（举例来说，"),s("em",[e._v("令B5.Value = B6.Value")]),e._v("）但是为了不让这个循环一直进行下去，要给循环设定一个界限，就是常用的"),s("code",[e._v("Usedrange.rows.count")]),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"定位法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定位法"}},[e._v("#")]),e._v(" 定位法")]),e._v(" "),s("p",[e._v("定位法相比循环法更为简单，先取消合并（此时会选中原先合并单元格的区域），然后定位空单元格，将这些单元格的值都等于他们的上一行的值就可以了。")]),e._v(" "),s("h1",{attrs:{id:"实战"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实战"}},[e._v("#")]),e._v(" 实战")]),e._v(" "),s("h2",{attrs:{id:"循环法-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环法-2"}},[e._v("#")]),e._v(" 循环法")]),e._v(" "),s("h3",{attrs:{id:"取消合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#取消合并"}},[e._v("#")]),e._v(" 取消合并")]),e._v(" "),s("p",[e._v("利用"),s("code",[e._v("UnMerge")]),e._v("方法取消合并单元格。")]),e._v(" "),s("h3",{attrs:{id:"建立循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#建立循环"}},[e._v("#")]),e._v(" 建立循环")]),e._v(" "),s("p",[e._v("设定循环的界限"),s("code",[e._v("ActiveSheet.UsedRange.Rows.Count")]),e._v("。利用"),s("code",[e._v("offset()")]),e._v("函数，让空值的单元格得到上一行的单元格的值"),s("code",[e._v('= Range("A" & i).Offset(-1, 0).Value')]),e._v("。")]),e._v(" "),s("h3",{attrs:{id:"代码块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码块"}},[e._v("#")]),e._v(" 代码块")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('Sub 循环法()\n    Range("A:A").UnMerge\n    For i = 2 To ActiveSheet.UsedRange.Rows.Count\n        If Range("A" & i).Value = "" Then Range("A" & i).Value = Range("A" & i).Offset(-1, 0).Value\n    Next i\nEnd Sub\n')])])]),s("h2",{attrs:{id:"定位法-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定位法-2"}},[e._v("#")]),e._v(" 定位法")]),e._v(" "),s("h3",{attrs:{id:"录制宏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#录制宏"}},[e._v("#")]),e._v(" 录制宏")]),e._v(" "),s("p",[e._v("先取消合并（此时会选中原先合并单元格的区域），直接按"),s("strong",[e._v("F5")]),e._v("，会出现"),s("em",[e._v("定位")]),e._v("窗口。点击左下角的按钮，再选择"),s("em",[e._v("空值")]),e._v("，此时会选中空单元格。之后在上方的"),s("em",[e._v("数值栏")]),e._v("当中输入"),s("code",[e._v("=a2")]),e._v("，按下"),s("strong",[e._v("Ctrl + Enter")]),e._v("，就会发现单元格的内容都自动填充好了。")]),e._v(" "),s("p",[s("img",{attrs:{src:t(218),alt:"enter image description here"}})]),e._v(" "),s("h3",{attrs:{id:"选取录制好的宏代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选取录制好的宏代码"}},[e._v("#")]),e._v(" 选取录制好的宏代码")]),e._v(" "),s("p",[e._v("尽管录制下来的宏代码看似很长很复杂，但是其实前面的都是一些没什么用的参数设置，与我们刚刚进行的操作有实际相关联的就是最后三句。将这三句进行复制，建立新的宏，并进行改造。")]),e._v(" "),s("p",[s("img",{attrs:{src:t(219),alt:"enter image description here"}})]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    Selection.UnMerge\n    Selection.SpecialCells(xlCellTypeBlanks).Select\n    Selection.FormulaR1C1 = "=R[-1]C"\n')])])]),s("h4",{attrs:{id:"unmerge"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unmerge"}},[e._v("#")]),e._v(" UnMerge")]),e._v(" "),s("p",[e._v("这是"),s("em",[e._v("取消合并")]),e._v("的操作，在宏代码中显示为"),s("code",[e._v("UnMerge")])]),e._v(" "),s("h4",{attrs:{id:"specialcells-xlcelltypeblanks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#specialcells-xlcelltypeblanks"}},[e._v("#")]),e._v(" SpecialCells(xlCellTypeBlanks)")]),e._v(" "),s("p",[e._v("这是定位特殊单元格的语法，在这里我们定位的是"),s("em",[e._v("空值")]),e._v("，所以括号里的内容是"),s("code",[e._v("Blanks")]),e._v("。")]),e._v(" "),s("h4",{attrs:{id:"formular1c1-r-1-c"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#formular1c1-r-1-c"}},[e._v("#")]),e._v(' FormulaR1C1 = "=R[-1]C"')]),e._v(" "),s("p",[e._v("这是我们最后在数值栏当中输入的公式，令值等于上一行（"),s("code",[e._v("R[-1]")]),e._v("）单元格（C）的值，大致用法与"),s("code",[e._v("offset()")]),e._v("函数一致。")]),e._v(" "),s("h3",{attrs:{id:"改造宏代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#改造宏代码"}},[e._v("#")]),e._v(" 改造宏代码")]),e._v(" "),s("p",[e._v("这一部分就相对简单了，首先我们要把"),s("code",[e._v("Selection")]),e._v("改成"),s("code",[e._v('Range("A:A")')]),e._v("，也就是让Excel自己选择A列，不用再让我们人工选定A列。之后可以把A列的值再赋值给A列，这是为了让单元格里显示的是数值而不是"),s("strong",[e._v("公式")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    Range("A:A").UnMerge\n    Range("A:A").SpecialCells(xlCellTypeBlanks).FormulaR1C1 = "=R[-1]C"\n    Range("A:A").Value = Range("A:A").Value\n')])])]),s("h3",{attrs:{id:"全部代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全部代码"}},[e._v("#")]),e._v(" 全部代码")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('Sub 定位法()\n\n    Range("A:A").UnMerge\n    Range("A:A").SpecialCells(xlCellTypeBlanks).FormulaR1C1 = "=R[-1]C"\n    Range("A:A").Value = Range("A:A").Value\n\nEnd Sub\n')])])])])}),[],!1,null,null,null);a.default=r.exports}}]);